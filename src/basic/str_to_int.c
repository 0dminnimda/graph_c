/* DO NOT CHANGE THIS FILE! GENERATED BY str_to_int/code_generator.py */

#include "str_to_int.h"

#include <stdlib.h>
#include "checked_arithmetic.h"

/* TODO: ignore leading zeros,
 * except leading 0b, 0o and 0x.

 * Allow to pass in a target base.

 * Allow to have leading + or -
 * (no spaces between them and number allowed).

 * Allow single underscores in the number
 * (except the first, last and characteres right after 0b,0o,0x).
 * Not allowed: _234, 456_, 0x_F, 0xF_
 * Allowed: 2_3_4, 0xF_A
 */

/* SEE:
 * https://github.com/lattera/glibc/blob/895ef79e04a953cac1493863bcae29ad85657ee1/stdlib/strtol_l.c
 * https://github.com/python/cpython/blob/6557af669899f18f8d123f8e1b6c3380d502c519/Objects/longobject.c#L2518
 */

/* The basic idea is that given a spefic type, you know it's maximum/minimum.
 * If you leave out the most significant digit (MSD) (make number out of one less digits then maximum)
 * then you can guarantee, there were no overflows while you are constructing it.
 * The only possible overflow is when you add MSD to the rest.

 * For example, for u8 all numbers from 0 to 99 are guranteed to fit,
 * but if you start parting 299, thus adding 200 and 99,
 * then you will need to check for overflow,
 * which ofter should be a single instruction and a jump.
 */

S2I_Result str_to_u8(str *string, u8 *value) {
    if (string->length == 0) return S2I_NOT_FOUND;
    char c = string->data[0];

    u8 msd;
    if ('0' <= c && c <= '9') {
        msd = c - '0';
    } else {
        return S2I_NOT_FOUND;
    }

    u8 msd_multiplier = 1;
    u8 rest = 0;
    u8 count = 1;
    for (; count < 3 && count < string->length; ++count) {
        c = string->data[count];
        if ('0' <= c && c <= '9') {
            msd_multiplier *= 10;
            rest = rest * 10 + (c - '0');
        } else {
            break;
        }
    }

    if (count != 3) {
        *value = msd * msd_multiplier + rest;
        string->data += count;
        string->length -= count;
        return S2I_OK;
    }

    if (count < string->length) {
        c = string->data[count];
        if ('0' <= c && c <= '9') {
            /* Got more than max digits, definitely not in range. */
            return S2I_OUT_OF_RANGE;
        }
    }

    if (msd > 2) {
        /* Most significant digit value exceeded it's limit */
        return S2I_OUT_OF_RANGE;
    }
    msd_multiplier *= msd;

    if (cheked_u_add(U8, value, msd_multiplier, rest)) {
        return S2I_OUT_OF_RANGE;
    }
    string->data += count;
    string->length -= count;
    return S2I_OK;
}

S2I_Result str_to_u16(str *string, u16 *value) {
    if (string->length == 0) return S2I_NOT_FOUND;
    char c = string->data[0];

    u8 msd;
    if ('0' <= c && c <= '9') {
        msd = c - '0';
    } else {
        return S2I_NOT_FOUND;
    }

    u16 msd_multiplier = 1;
    u16 rest = 0;
    u8 count = 1;
    for (; count < 5 && count < string->length; ++count) {
        c = string->data[count];
        if ('0' <= c && c <= '9') {
            msd_multiplier *= 10;
            rest = rest * 10 + (c - '0');
        } else {
            break;
        }
    }

    if (count != 5) {
        *value = msd * msd_multiplier + rest;
        string->data += count;
        string->length -= count;
        return S2I_OK;
    }

    if (count < string->length) {
        c = string->data[count];
        if ('0' <= c && c <= '9') {
            /* Got more than max digits, definitely not in range. */
            return S2I_OUT_OF_RANGE;
        }
    }

    if (msd > 6) {
        /* Most significant digit value exceeded it's limit */
        return S2I_OUT_OF_RANGE;
    }
    msd_multiplier *= msd;

    if (cheked_u_add(U16, value, msd_multiplier, rest)) {
        return S2I_OUT_OF_RANGE;
    }
    string->data += count;
    string->length -= count;
    return S2I_OK;
}

S2I_Result str_to_u32(str *string, u32 *value) {
    if (string->length == 0) return S2I_NOT_FOUND;
    char c = string->data[0];

    u8 msd;
    if ('0' <= c && c <= '9') {
        msd = c - '0';
    } else {
        return S2I_NOT_FOUND;
    }

    u32 msd_multiplier = 1;
    u32 rest = 0;
    u8 count = 1;
    for (; count < 10 && count < string->length; ++count) {
        c = string->data[count];
        if ('0' <= c && c <= '9') {
            msd_multiplier *= 10;
            rest = rest * 10 + (c - '0');
        } else {
            break;
        }
    }

    if (count != 10) {
        *value = msd * msd_multiplier + rest;
        string->data += count;
        string->length -= count;
        return S2I_OK;
    }

    if (count < string->length) {
        c = string->data[count];
        if ('0' <= c && c <= '9') {
            /* Got more than max digits, definitely not in range. */
            return S2I_OUT_OF_RANGE;
        }
    }

    if (msd > 4) {
        /* Most significant digit value exceeded it's limit */
        return S2I_OUT_OF_RANGE;
    }
    msd_multiplier *= msd;

    if (cheked_u_add(U32, value, msd_multiplier, rest)) {
        return S2I_OUT_OF_RANGE;
    }
    string->data += count;
    string->length -= count;
    return S2I_OK;
}

S2I_Result str_to_u64(str *string, u64 *value) {
    if (string->length == 0) return S2I_NOT_FOUND;
    char c = string->data[0];

    u8 msd;
    if ('0' <= c && c <= '9') {
        msd = c - '0';
    } else {
        return S2I_NOT_FOUND;
    }

    u64 msd_multiplier = 1;
    u64 rest = 0;
    u8 count = 1;
    for (; count < 20 && count < string->length; ++count) {
        c = string->data[count];
        if ('0' <= c && c <= '9') {
            msd_multiplier *= 10;
            rest = rest * 10 + (c - '0');
        } else {
            break;
        }
    }

    if (count != 20) {
        *value = msd * msd_multiplier + rest;
        string->data += count;
        string->length -= count;
        return S2I_OK;
    }

    if (count < string->length) {
        c = string->data[count];
        if ('0' <= c && c <= '9') {
            /* Got more than max digits, definitely not in range. */
            return S2I_OUT_OF_RANGE;
        }
    }

    if (msd > 1) {
        /* Most significant digit value exceeded it's limit */
        return S2I_OUT_OF_RANGE;
    }
    msd_multiplier *= msd;

    if (cheked_u_add(U64, value, msd_multiplier, rest)) {
        return S2I_OUT_OF_RANGE;
    }
    string->data += count;
    string->length -= count;
    return S2I_OK;
}


S2I_Result str_to_s8(str *string, s8 *value) {
    (void)string;
    (void)value;
    return S2I_NOT_FOUND;
}

S2I_Result str_to_s16(str *string, s16 *value) {
    (void)string;
    (void)value;
    return S2I_NOT_FOUND;
}

S2I_Result str_to_s32(str *string, s32 *value) {
    (void)string;
    (void)value;
    return S2I_NOT_FOUND;
}

S2I_Result str_to_s64(str *string, s64 *value) {
    (void)string;
    (void)value;
    return S2I_NOT_FOUND;
}

